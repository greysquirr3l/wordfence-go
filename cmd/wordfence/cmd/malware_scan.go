package cmd

import (
	"bufio"
	"context"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/spf13/cobra"

	"github.com/greysquirr3l/wordfence-go/internal/api"
	"github.com/greysquirr3l/wordfence-go/internal/cache"
	"github.com/greysquirr3l/wordfence-go/internal/config"
	"github.com/greysquirr3l/wordfence-go/internal/intel"
	"github.com/greysquirr3l/wordfence-go/internal/logging"
	"github.com/greysquirr3l/wordfence-go/internal/scanner"
)

var (
	malwareScanOutput         string
	malwareScanOutputFormat   string
	malwareScanWorkers        int
	malwareScanIncludeAll     bool
	malwareScanReadStdin      bool
	malwareScanIncludeFiles   []string
	malwareScanIncludePattern []string
	malwareScanExcludeFiles   []string
	malwareScanExcludePattern []string
	// Resource control flags
	malwareScanChunkSize      int
	malwareScanContentLimit   int64
	malwareScanMatchTimeout   int
	malwareScanAllowIOErrors  bool
	malwareScanFollowSymlinks bool
	malwareScanScanDelay      int
	// Advanced resource control flags
	malwareScanMemoryLimit int
	malwareScanIOLimit     int64
	malwareScanBatchSize   int
	malwareScanBatchPause  int
	malwareScanMaxLoad     float64
	// Performance profile
	malwareScanProfile string
	// Pipeline mode
	malwareScanPipeline bool
)

var malwareScanCmd = &cobra.Command{
	Use:   "malware-scan [paths...]",
	Short: "Scan files for malware",
	Long: `Scan files and directories for malware using Wordfence signatures.

The scanner will recursively scan the specified paths for files matching
known malware signatures. By default, only PHP, HTML, and JS files are
scanned unless --include-all-files is specified.`,
	Example: `  # Scan a single directory
  wordfence malware-scan /var/www

  # Scan multiple directories
  wordfence malware-scan /var/www/site1 /var/www/site2

  # Scan with CSV output
  wordfence malware-scan --output-format csv --output results.csv /var/www

  # Scan files from stdin
  find /var/www -name "*.php" | wordfence malware-scan --read-stdin`,
	Args: func(_ *cobra.Command, args []string) error {
		if !malwareScanReadStdin && len(args) == 0 {
			return fmt.Errorf("at least one path is required (or use --read-stdin)")
		}
		return nil
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		return runMalwareScan(cmd.Context(), args)
	},
}

func init() {
	malwareScanCmd.Flags().StringVarP(&malwareScanOutput, "output", "o", "", "output file (default: stdout)")
	malwareScanCmd.Flags().StringVar(&malwareScanOutputFormat, "output-format", "human", "output format: csv, tsv, json, human")
	malwareScanCmd.Flags().IntVarP(&malwareScanWorkers, "workers", "w", 0, "number of worker goroutines (default: NumCPU)")
	malwareScanCmd.Flags().BoolVar(&malwareScanIncludeAll, "include-all-files", false, "scan all files, not just PHP/HTML/JS")
	malwareScanCmd.Flags().BoolVar(&malwareScanReadStdin, "read-stdin", false, "read paths from stdin")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanIncludeFiles, "include-files", nil, "additional filenames to include")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanIncludePattern, "include-pattern", nil, "regex patterns for files to include")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanExcludeFiles, "exclude-files", nil, "filenames to exclude")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanExcludePattern, "exclude-pattern", nil, "regex patterns to exclude")

	// Resource control flags
	malwareScanCmd.Flags().IntVar(&malwareScanChunkSize, "chunk-size", 0, "memory buffer size in KB for reading files (default: 1024)")
	malwareScanCmd.Flags().Int64Var(&malwareScanContentLimit, "max-file-size", 0, "maximum file size to scan in MB (0 = unlimited)")
	malwareScanCmd.Flags().IntVar(&malwareScanMatchTimeout, "match-timeout", 0, "timeout in seconds for each regex match (default: 1)")
	malwareScanCmd.Flags().BoolVar(&malwareScanAllowIOErrors, "allow-io-errors", false, "continue scanning on file read errors")
	malwareScanCmd.Flags().BoolVar(&malwareScanFollowSymlinks, "follow-symlinks", false, "follow symbolic links during scan")
	malwareScanCmd.Flags().IntVar(&malwareScanScanDelay, "scan-delay", 0, "delay in milliseconds between scanning each file (reduces CPU/IO pressure)")

	// Advanced resource control flags
	malwareScanCmd.Flags().IntVar(&malwareScanMemoryLimit, "memory-limit", 0, "max memory usage in MB before throttling (0 = unlimited)")
	malwareScanCmd.Flags().Int64Var(&malwareScanIOLimit, "io-rate-limit", 0, "max bytes per second to read from disk in MB/s (0 = unlimited)")
	malwareScanCmd.Flags().IntVar(&malwareScanBatchSize, "batch-size", 0, "scan N files then pause (use with --batch-pause)")
	malwareScanCmd.Flags().IntVar(&malwareScanBatchPause, "batch-pause", 0, "milliseconds to pause after each batch (use with --batch-size)")
	malwareScanCmd.Flags().Float64Var(&malwareScanMaxLoad, "max-load", 0, "pause when system load exceeds this value (Unix only, 0 = no limit)")

	// Performance profile
	malwareScanCmd.Flags().StringVar(&malwareScanProfile, "profile", "", "performance profile: gentle, balanced, aggressive, adaptive")

	// Pipeline mode (advanced)
	malwareScanCmd.Flags().BoolVar(&malwareScanPipeline, "pipeline", false, "use pipeline architecture with buffer pooling, rate limiting, and circuit breaker")

	rootCmd.AddCommand(malwareScanCmd)
}

func runMalwareScan(ctx context.Context, paths []string) error {
	cfg := GetConfig()
	if cfg == nil {
		return fmt.Errorf("configuration not loaded")
	}

	// Check for license
	if err := checkLicense(cfg); err != nil {
		return err
	}

	// Collect paths
	paths, err := collectScanPaths(paths)
	if err != nil {
		return err
	}

	logging.Info("Starting malware scan...")

	// Create and validate API client
	license := api.NewLicense(cfg.License)
	noc1 := api.NewNOC1Client(api.WithNOC1License(license))
	if err := validateLicense(ctx, noc1, license); err != nil {
		return err
	}

	// Set up cache
	fileCache := setupCache(cfg)

	// Load signatures
	sigSet, err := loadSignatures(ctx, noc1, fileCache)
	if err != nil {
		return fmt.Errorf("failed to load signatures: %w", err)
	}
	logging.Info("Loaded %d signatures", sigSet.Count())

	// Set up output
	output, cleanup, err := setupOutput()
	if err != nil {
		return err
	}
	defer cleanup()

	writer := newResultWriter(output, malwareScanOutputFormat)
	defer func() { _ = writer.Close() }()

	// Choose pipeline or traditional scanner
	if malwareScanPipeline {
		return executePipelineScan(ctx, sigSet, paths, writer)
	}

	// Create traditional scanner (with profile or manual options)
	s, err := createScanner(sigSet)
	if err != nil {
		return err
	}

	// Run the scan
	return executeScan(ctx, s, paths, writer, sigSet)
}

// checkLicense validates that a license is configured
func checkLicense(cfg *config.Config) error {
	if cfg.License == "" {
		logging.Error("No license key configured.")
		logging.Info("You can configure your license in one of the following ways:")
		logging.Info("  1. Config file: %s", config.DefaultConfigPath())
		logging.Info("     Add: license = YOUR_LICENSE_KEY")
		logging.Info("  2. Environment: export WORDFENCE_CLI_LICENSE=YOUR_LICENSE_KEY")
		logging.Info("  3. CLI flag: --license YOUR_LICENSE_KEY")
		logging.Info("")
		logging.Info("Visit https://www.wordfence.com/products/wordfence-cli/ to obtain a license.")
		return fmt.Errorf("license required")
	}
	return nil
}

// collectScanPaths gathers paths from args and stdin
func collectScanPaths(paths []string) ([]string, error) {
	if malwareScanReadStdin {
		stdinPaths, err := readPathsFromStdin()
		if err != nil {
			return nil, fmt.Errorf("failed to read paths from stdin: %w", err)
		}
		paths = append(paths, stdinPaths...)
	}
	if len(paths) == 0 {
		return nil, fmt.Errorf("no paths to scan")
	}
	return paths, nil
}

// validateLicense checks the license with the API
func validateLicense(ctx context.Context, noc1 *api.NOC1Client, license *api.License) error {
	logging.Verbose("Validating license...")
	valid, err := noc1.PingAPIKey(ctx)
	if err != nil {
		return fmt.Errorf("license validation failed: %w", err)
	}
	if !valid {
		return fmt.Errorf("invalid license key")
	}
	logging.Verbose("License valid (paid: %v)", license.Paid)
	return nil
}

// setupCache creates the appropriate cache implementation
func setupCache(cfg *config.Config) cache.Cache {
	if !cfg.CacheEnabled {
		return &cache.NoOpCache{}
	}

	cacheDir := cfg.CacheDirectory
	if cacheDir == "" {
		var err error
		cacheDir, err = cache.DefaultCacheDir()
		if err != nil {
			logging.Warning("Failed to get default cache directory: %v", err)
			return &cache.NoOpCache{}
		}
	}

	fileCache, err := cache.NewFileCache(cacheDir)
	if err != nil {
		logging.Warning("Failed to create file cache: %v", err)
		return &cache.NoOpCache{}
	}
	return fileCache
}

// createScanner builds a scanner with the appropriate options
func createScanner(sigSet *intel.SignatureSet) (scannerInterface, error) {
	// If a profile is specified, use it as base
	if malwareScanProfile != "" {
		return createProfileScanner(sigSet)
	}
	return createManualScanner(sigSet)
}

// scannerInterface allows both Scanner and AdaptiveScanner to be used
type scannerInterface interface {
	Scan(ctx context.Context, paths ...string) (<-chan *scanner.ScanResult, error)
	GetStats() scanner.ScanStats
}

// createProfileScanner creates a scanner using a performance profile
func createProfileScanner(sigSet *intel.SignatureSet) (scannerInterface, error) {
	profile := scanner.Profile(malwareScanProfile)
	profiles := scanner.DefaultProfiles()
	settings, ok := profiles[profile]
	if !ok {
		return nil, fmt.Errorf("unknown profile: %s (valid: gentle, balanced, aggressive, adaptive)", malwareScanProfile)
	}

	logging.Info("Using performance profile: %s", malwareScanProfile)
	logProfileSettings(settings)

	// For adaptive profile, use AdaptiveScanner with ResourceMonitor
	if profile == scanner.ProfileAdaptive {
		logging.Info("Adaptive mode: resource monitor will dynamically adjust settings")
		opts := buildAdaptiveOverrides()
		return scanner.NewAdaptiveScanner(sigSet, profile, opts...), nil
	}

	// Start with profile settings, allow CLI overrides
	opts := buildProfileOptions(settings)
	return scanner.NewScanner(sigSet, opts...), nil
}

// buildAdaptiveOverrides returns options that override adaptive defaults from CLI
func buildAdaptiveOverrides() []scanner.Option {
	var opts []scanner.Option

	// Only add options if explicitly set via CLI
	if malwareScanWorkers > 0 {
		opts = append(opts, scanner.WithScanWorkers(malwareScanWorkers))
	}
	if malwareScanMatchTimeout > 0 {
		opts = append(opts, scanner.WithScanMatchTimeout(time.Duration(malwareScanMatchTimeout)*time.Second))
	}
	if malwareScanContentLimit > 0 {
		opts = append(opts, scanner.WithContentLimit(malwareScanContentLimit*1024*1024))
	}
	if malwareScanAllowIOErrors {
		opts = append(opts, scanner.WithAllowIOErrors(true))
	}
	if malwareScanFollowSymlinks {
		opts = append(opts, scanner.WithFollowSymlinks(true))
	}

	// Add filter
	filter := buildFileFilter()
	opts = append(opts, scanner.WithScanFilter(filter))

	return opts
}

// logProfileSettings logs the profile configuration
func logProfileSettings(s scanner.ProfileSettings) {
	logging.Debug("  Workers: %d", s.Workers)
	if s.ScanDelayMS > 0 {
		logging.Debug("  Scan delay: %dms", s.ScanDelayMS)
	}
	if s.MemoryLimitMB > 0 {
		logging.Debug("  Memory limit: %dMB", s.MemoryLimitMB)
	}
	if s.MaxLoadAvg > 0 {
		logging.Debug("  Max load: %.2f", s.MaxLoadAvg)
	}
}

// buildProfileOptions creates scanner options from profile settings with CLI overrides
func buildProfileOptions(settings scanner.ProfileSettings) []scanner.Option {
	opts := []scanner.Option{
		scanner.WithAllowIOErrors(malwareScanAllowIOErrors),
		scanner.WithFollowSymlinks(malwareScanFollowSymlinks),
	}

	// Use profile setting or CLI override
	workers := settings.Workers
	if malwareScanWorkers > 0 {
		workers = malwareScanWorkers
	}
	opts = append(opts, scanner.WithScanWorkers(workers))

	// Apply profile settings
	if settings.ScanDelayMS > 0 || malwareScanScanDelay > 0 {
		delay := settings.ScanDelayMS
		if malwareScanScanDelay > 0 {
			delay = malwareScanScanDelay
		}
		opts = append(opts, scanner.WithScanDelay(time.Duration(delay)*time.Millisecond))
	}

	if settings.ChunkSizeKB > 0 || malwareScanChunkSize > 0 {
		size := settings.ChunkSizeKB
		if malwareScanChunkSize > 0 {
			size = malwareScanChunkSize
		}
		opts = append(opts, scanner.WithChunkSize(size*1024))
	}

	if settings.MaxFileSizeMB > 0 || malwareScanContentLimit > 0 {
		limit := int64(settings.MaxFileSizeMB)
		if malwareScanContentLimit > 0 {
			limit = malwareScanContentLimit
		}
		opts = append(opts, scanner.WithContentLimit(limit*1024*1024))
	}

	if settings.BatchSize > 0 || malwareScanBatchSize > 0 {
		batch := settings.BatchSize
		if malwareScanBatchSize > 0 {
			batch = malwareScanBatchSize
		}
		opts = append(opts, scanner.WithBatchSize(batch))
	}

	if settings.BatchPauseMS > 0 || malwareScanBatchPause > 0 {
		pause := settings.BatchPauseMS
		if malwareScanBatchPause > 0 {
			pause = malwareScanBatchPause
		}
		opts = append(opts, scanner.WithBatchPause(pause))
	}

	if settings.MaxLoadAvg > 0 || malwareScanMaxLoad > 0 {
		load := settings.MaxLoadAvg
		if malwareScanMaxLoad > 0 {
			load = malwareScanMaxLoad
		}
		opts = append(opts, scanner.WithMaxLoadAvg(load))
	}

	if settings.MemoryLimitMB > 0 || malwareScanMemoryLimit > 0 {
		mem := settings.MemoryLimitMB
		if malwareScanMemoryLimit > 0 {
			mem = malwareScanMemoryLimit
		}
		opts = append(opts, scanner.WithMemoryLimit(mem))
	}

	if settings.IOLimitMBps > 0 || malwareScanIOLimit > 0 {
		io := settings.IOLimitMBps
		if malwareScanIOLimit > 0 {
			io = malwareScanIOLimit
		}
		opts = append(opts, scanner.WithIOBytesPerSec(io*1024*1024))
	}

	// Add filter
	filterCfg := &scanner.FilterConfig{
		IncludeAll:      malwareScanIncludeAll,
		IncludeFiles:    malwareScanIncludeFiles,
		IncludePatterns: malwareScanIncludePattern,
		ExcludeFiles:    malwareScanExcludeFiles,
		ExcludePatterns: malwareScanExcludePattern,
	}
	filter, err := scanner.NewFilterFromConfig(filterCfg)
	if err == nil {
		opts = append(opts, scanner.WithScanFilter(filter))
	}

	return opts
}

// createManualScanner creates a scanner with manual CLI options
func createManualScanner(sigSet *intel.SignatureSet) (scannerInterface, error) {
	workers := malwareScanWorkers
	if workers <= 0 {
		workers = runtime.NumCPU()
	}
	logging.Debug("Workers: %d", workers)

	filterCfg := &scanner.FilterConfig{
		IncludeAll:      malwareScanIncludeAll,
		IncludeFiles:    malwareScanIncludeFiles,
		IncludePatterns: malwareScanIncludePattern,
		ExcludeFiles:    malwareScanExcludeFiles,
		ExcludePatterns: malwareScanExcludePattern,
	}
	filter, err := scanner.NewFilterFromConfig(filterCfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create file filter: %w", err)
	}

	opts := buildManualOptions(workers, filter)
	return scanner.NewScanner(sigSet, opts...), nil
}

// buildManualOptions creates scanner options from CLI flags
func buildManualOptions(workers int, filter *scanner.FileFilter) []scanner.Option {
	opts := []scanner.Option{
		scanner.WithScanWorkers(workers),
		scanner.WithScanFilter(filter),
		scanner.WithAllowIOErrors(malwareScanAllowIOErrors),
		scanner.WithFollowSymlinks(malwareScanFollowSymlinks),
	}

	if malwareScanChunkSize > 0 {
		opts = append(opts, scanner.WithChunkSize(malwareScanChunkSize*1024))
	}
	if malwareScanContentLimit > 0 {
		opts = append(opts, scanner.WithContentLimit(malwareScanContentLimit*1024*1024))
	}
	if malwareScanMatchTimeout > 0 {
		opts = append(opts, scanner.WithScanMatchTimeout(time.Duration(malwareScanMatchTimeout)*time.Second))
	}
	if malwareScanScanDelay > 0 {
		opts = append(opts, scanner.WithScanDelay(time.Duration(malwareScanScanDelay)*time.Millisecond))
		logging.Debug("Scan delay: %dms", malwareScanScanDelay)
	}
	if malwareScanMemoryLimit > 0 {
		opts = append(opts, scanner.WithMemoryLimit(malwareScanMemoryLimit))
		logging.Debug("Memory limit: %dMB", malwareScanMemoryLimit)
	}
	if malwareScanIOLimit > 0 {
		opts = append(opts, scanner.WithIOBytesPerSec(malwareScanIOLimit*1024*1024))
		logging.Debug("I/O rate limit: %dMB/s", malwareScanIOLimit)
	}
	if malwareScanBatchSize > 0 && malwareScanBatchPause > 0 {
		opts = append(opts, scanner.WithBatchSize(malwareScanBatchSize))
		opts = append(opts, scanner.WithBatchPause(malwareScanBatchPause))
		logging.Debug("Batch: %d files, %dms pause", malwareScanBatchSize, malwareScanBatchPause)
	}
	if malwareScanMaxLoad > 0 {
		opts = append(opts, scanner.WithMaxLoadAvg(malwareScanMaxLoad))
		logging.Debug("Max load: %.2f", malwareScanMaxLoad)
	}

	return opts
}

// setupOutput configures the output destination
func setupOutput() (*os.File, func(), error) {
	if malwareScanOutput != "" {
		output, err := os.Create(malwareScanOutput) // #nosec G304 -- user-specified output file
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create output file: %w", err)
		}
		return output, func() { _ = output.Close() }, nil
	}
	return os.Stdout, func() {}, nil
}

// executeScan runs the scan and processes results
func executeScan(ctx context.Context, s scannerInterface, paths []string, writer resultWriter, sigSet *intel.SignatureSet) error {
	results, err := s.Scan(ctx, paths...)
	if err != nil {
		return fmt.Errorf("scan failed: %w", err)
	}

	matchCount := 0
	for result := range results {
		if result.Error != nil {
			logging.Warning("Error scanning %s: %v", result.Path, result.Error)
			continue
		}
		if result.HasMatches() {
			matchCount += len(result.Matches)
			if err := writer.WriteResult(result, sigSet); err != nil {
				logging.Warning("Error writing result: %v", err)
			}
		}
	}

	printScanSummary(s, matchCount)
	return nil
}

// executePipelineScan runs the scan using the pipeline architecture
func executePipelineScan(ctx context.Context, sigSet *intel.SignatureSet, paths []string, writer resultWriter) error {
	logging.Info("Using pipeline scanner with buffer pooling, rate limiting, and circuit breaker")

	// Build pipeline scanner options
	opts := buildPipelineOptions()

	// Create pipeline scanner
	ps := scanner.NewPipelineScanner(sigSet, opts...)

	// Handle graceful shutdown on context cancellation
	go func() {
		<-ctx.Done()
		// Creating new context for shutdown is intentional - parent context is already cancelled
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		if err := ps.Shutdown(shutdownCtx); err != nil { //nolint:contextcheck
			logging.Warning("Graceful shutdown incomplete: %v", err)
		}
	}()

	logging.Info("Scan ID: %s", ps.GetScanID())

	results, err := ps.Scan(ctx, paths...)
	if err != nil {
		return fmt.Errorf("pipeline scan failed: %w", err)
	}

	matchCount := 0
	for result := range results {
		if result.Error != nil {
			logging.Warning("Error scanning %s: %v", result.Path, result.Error)
			continue
		}
		if result.HasMatches() {
			matchCount += len(result.Matches)
			if err := writer.WriteResult(result, sigSet); err != nil {
				logging.Warning("Error writing result: %v", err)
			}
		}
	}

	printPipelineScanSummary(ps, matchCount)
	return nil
}

// buildPipelineOptions creates options for the pipeline scanner
func buildPipelineOptions() []scanner.PipelineOption {
	opts := []scanner.PipelineOption{
		scanner.WithPipelineAllowIOErrors(malwareScanAllowIOErrors),
		scanner.WithPipelineFollowSymlinks(malwareScanFollowSymlinks),
	}

	// Workers
	workers := malwareScanWorkers
	if workers <= 0 {
		workers = runtime.NumCPU()
	}
	opts = append(opts, scanner.WithPipelineWorkers(workers))

	// Match timeout
	if malwareScanMatchTimeout > 0 {
		opts = append(opts, scanner.WithPipelineMatchTimeout(time.Duration(malwareScanMatchTimeout)*time.Second))
	} else {
		opts = append(opts, scanner.WithPipelineMatchTimeout(time.Second))
	}

	// Content limit
	if malwareScanContentLimit > 0 {
		opts = append(opts, scanner.WithPipelineContentLimit(malwareScanContentLimit*1024*1024))
	}

	// I/O rate limit (convert MB/s to bytes/s)
	if malwareScanIOLimit > 0 {
		opts = append(opts, scanner.WithPipelineIOLimit(malwareScanIOLimit*1024*1024))
	}

	// Circuit breaker (5 failures, 30s timeout)
	opts = append(opts, scanner.WithPipelineCircuitBreaker(5, 30*time.Second))

	// Resource monitor for adaptive profile
	if malwareScanProfile == "adaptive" {
		logging.Info("Pipeline using adaptive resource monitoring (100ms interval)")
		opts = append(opts, scanner.WithPipelineResourceMonitor(100*time.Millisecond))
	}

	// File filter
	filter := buildFileFilter()
	opts = append(opts, scanner.WithPipelineFilter(filter))

	return opts
}

// printPipelineScanSummary outputs the pipeline scan statistics
func printPipelineScanSummary(ps *scanner.PipelineScanner, matchCount int) {
	stats := ps.GetStats()
	logging.Info("")
	logging.Info("Pipeline scan complete:")
	logging.Info("  Stage: Discovered: %d → Filtered: %d → Read: %d → Matched: %d → Reported: %d",
		stats.Discovered, stats.Filtered, stats.Read, stats.Matched, stats.Reported)
	logging.Info("  Files with matches: %d", stats.FilesWithMatches)
	logging.Info("  Files skipped: %d", stats.FilesSkipped)
	logging.Info("  Files errored: %d", stats.FilesErrored)
	logging.Info("  Duplicates skipped: %d", stats.DuplicatesSkipped)
	logging.Info("  Total matches: %d", matchCount)
	logging.Info("  Bytes scanned: %d MB", stats.BytesScanned/(1024*1024))
	logging.Info("  Duration: %v", stats.Duration.Round(time.Millisecond))
	logging.Info("  Buffer pool hit rate: %.1f%%", stats.BufferPoolHitRate*100)
	if stats.CircuitBreaks > 0 {
		logging.Warning("  Circuit breaker trips: %d", stats.CircuitBreaks)
	}
	if stats.RateLimitWaits > 0 {
		logging.Info("  Rate limit waits: %d", stats.RateLimitWaits)
	}
}

// buildFileFilter creates a file filter from CLI flags
func buildFileFilter() *scanner.FileFilter {
	filterCfg := &scanner.FilterConfig{
		IncludeAll:      malwareScanIncludeAll,
		IncludeFiles:    malwareScanIncludeFiles,
		IncludePatterns: malwareScanIncludePattern,
		ExcludeFiles:    malwareScanExcludeFiles,
		ExcludePatterns: malwareScanExcludePattern,
	}
	filter, err := scanner.NewFilterFromConfig(filterCfg)
	if err != nil {
		logging.Warning("Failed to create filter from config: %v, using default", err)
		return scanner.DefaultFilter()
	}
	return filter
}

// printScanSummary outputs the scan statistics
func printScanSummary(s scannerInterface, matchCount int) {
	stats := s.GetStats()
	logging.Info("")
	logging.Info("Scan complete:")
	logging.Info("  Files scanned: %d", stats.FilesScanned)
	logging.Info("  Files matched: %d", stats.FilesMatched)
	logging.Info("  Files skipped: %d", stats.FilesSkipped)
	logging.Info("  Files errored: %d", stats.FilesErrored)
	logging.Info("  Total matches: %d", matchCount)
	logging.Info("  Duration: %v", stats.TotalDuration.Round(time.Millisecond))
}

func readPathsFromStdin() ([]string, error) {
	var paths []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		path := strings.TrimSpace(scanner.Text())
		if path != "" {
			paths = append(paths, path)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("reading stdin: %w", err)
	}
	return paths, nil
}

func loadSignatures(ctx context.Context, noc1 *api.NOC1Client, c cache.Cache) (*intel.SignatureSet, error) {
	// Create a signature loader
	loader := intel.NewSignatureLoader(c)

	// Use LoadOrFetch which will try cache, then embedded, then API
	fetchFn := func(ctx context.Context) (*intel.SignatureSet, error) {
		logging.Verbose("Fetching signatures from Wordfence API...")
		return noc1.GetPatternsAsSignatureSet(ctx)
	}

	// Check if we have embedded rules
	if intel.HasEmbedded() {
		logging.Debug("Binary has embedded signatures")
	}

	sigSet, err := loader.LoadOrFetch(ctx, fetchFn)
	if err != nil {
		return nil, fmt.Errorf("loading signatures: %w", err)
	}
	return sigSet, nil
}

// Output format constants
const (
	formatCSV   = "csv"
	formatTSV   = "tsv"
	formatJSON  = "json"
	formatHuman = "human"
)

// resultWriter writes scan results in various formats
type resultWriter interface {
	WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error
	Close() error
}

func newResultWriter(output *os.File, format string) resultWriter {
	switch format {
	case formatCSV:
		return newCSVWriter(output, ',')
	case formatTSV:
		return newCSVWriter(output, '\t')
	case formatJSON:
		return newJSONWriter(output)
	default:
		return newHumanWriter(output)
	}
}

// csvWriter writes results in CSV format
type csvWriter struct {
	writer *csv.Writer
	first  bool
}

func newCSVWriter(output *os.File, delim rune) *csvWriter {
	w := csv.NewWriter(output)
	w.Comma = delim
	// Write header
	_ = w.Write([]string{"filename", "signature_id", "signature_name", "signature_description", "matched_text"})
	return &csvWriter{writer: w, first: true}
}

func (w *csvWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := ""
		desc := ""
		if sig != nil {
			name = sig.Name
			desc = sig.Description
		}
		_ = w.writer.Write([]string{
			result.Path,
			fmt.Sprintf("%d", match.SignatureID),
			name,
			desc,
			match.MatchedString,
		})
	}
	return nil
}

func (w *csvWriter) Close() error {
	w.writer.Flush()
	if err := w.writer.Error(); err != nil {
		return fmt.Errorf("csv writer error: %w", err)
	}
	return nil
}

// jsonWriter writes results in JSON format
type jsonWriter struct {
	output  *os.File
	encoder *json.Encoder
	first   bool
}

func newJSONWriter(output *os.File) *jsonWriter {
	_, _ = output.WriteString("[\n")
	return &jsonWriter{output: output, encoder: json.NewEncoder(output), first: true}
}

type jsonResult struct {
	Filename             string `json:"filename"`
	SignatureID          int    `json:"signature_id"`
	SignatureName        string `json:"signature_name"`
	SignatureDescription string `json:"signature_description"`
	MatchedText          string `json:"matched_text"`
}

func (w *jsonWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := ""
		desc := ""
		if sig != nil {
			name = sig.Name
			desc = sig.Description
		}

		if !w.first {
			_, _ = w.output.WriteString(",\n")
		}
		w.first = false

		jr := jsonResult{
			Filename:             result.Path,
			SignatureID:          match.SignatureID,
			SignatureName:        name,
			SignatureDescription: desc,
			MatchedText:          match.MatchedString,
		}
		data, _ := json.MarshalIndent(jr, "  ", "  ")
		_, _ = w.output.WriteString("  ")
		_, _ = w.output.Write(data)
	}
	return nil
}

func (w *jsonWriter) Close() error {
	_, _ = w.output.WriteString("\n]\n")
	return nil
}

// humanWriter writes results in human-readable format
type humanWriter struct {
	output *os.File
}

func newHumanWriter(output *os.File) *humanWriter {
	return &humanWriter{output: output}
}

func (w *humanWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	red := color.New(color.FgRed, color.Bold)
	yellow := color.New(color.FgYellow)

	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := fmt.Sprintf("Signature %d", match.SignatureID)
		if sig != nil && sig.Name != "" {
			name = sig.Name
		}

		_, _ = red.Fprintf(w.output, "FOUND: ")
		_, _ = fmt.Fprintf(w.output, "%s\n", result.Path)
		_, _ = yellow.Fprintf(w.output, "  %s", name)
		if sig != nil && sig.Description != "" {
			_, _ = fmt.Fprintf(w.output, " - %s", sig.Description)
		}
		_, _ = fmt.Fprintln(w.output)
	}
	return nil
}

func (w *humanWriter) Close() error {
	return nil
}
