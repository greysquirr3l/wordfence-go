package cmd

import (
	"bufio"
	"context"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/spf13/cobra"

	"github.com/nickcampbell/wordfence-go/internal/api"
	"github.com/nickcampbell/wordfence-go/internal/cache"
	"github.com/nickcampbell/wordfence-go/internal/intel"
	"github.com/nickcampbell/wordfence-go/internal/logging"
	"github.com/nickcampbell/wordfence-go/internal/scanner"
)

var (
	malwareScanOutput         string
	malwareScanOutputFormat   string
	malwareScanWorkers        int
	malwareScanIncludeAll     bool
	malwareScanReadStdin      bool
	malwareScanIncludeFiles   []string
	malwareScanIncludePattern []string
	malwareScanExcludeFiles   []string
	malwareScanExcludePattern []string
)

var malwareScanCmd = &cobra.Command{
	Use:   "malware-scan [paths...]",
	Short: "Scan files for malware",
	Long: `Scan files and directories for malware using Wordfence signatures.

The scanner will recursively scan the specified paths for files matching
known malware signatures. By default, only PHP, HTML, and JS files are
scanned unless --include-all-files is specified.`,
	Example: `  # Scan a single directory
  wordfence malware-scan /var/www

  # Scan multiple directories
  wordfence malware-scan /var/www/site1 /var/www/site2

  # Scan with CSV output
  wordfence malware-scan --output-format csv --output results.csv /var/www

  # Scan files from stdin
  find /var/www -name "*.php" | wordfence malware-scan --read-stdin`,
	Args: func(cmd *cobra.Command, args []string) error {
		if !malwareScanReadStdin && len(args) == 0 {
			return fmt.Errorf("at least one path is required (or use --read-stdin)")
		}
		return nil
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		return runMalwareScan(cmd.Context(), args)
	},
}

func init() {
	malwareScanCmd.Flags().StringVarP(&malwareScanOutput, "output", "o", "", "output file (default: stdout)")
	malwareScanCmd.Flags().StringVar(&malwareScanOutputFormat, "output-format", "human", "output format: csv, tsv, json, human")
	malwareScanCmd.Flags().IntVarP(&malwareScanWorkers, "workers", "w", 0, "number of worker goroutines (default: NumCPU)")
	malwareScanCmd.Flags().BoolVar(&malwareScanIncludeAll, "include-all-files", false, "scan all files, not just PHP/HTML/JS")
	malwareScanCmd.Flags().BoolVar(&malwareScanReadStdin, "read-stdin", false, "read paths from stdin")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanIncludeFiles, "include-files", nil, "additional filenames to include")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanIncludePattern, "include-pattern", nil, "regex patterns for files to include")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanExcludeFiles, "exclude-files", nil, "filenames to exclude")
	malwareScanCmd.Flags().StringSliceVar(&malwareScanExcludePattern, "exclude-pattern", nil, "regex patterns to exclude")

	rootCmd.AddCommand(malwareScanCmd)
}

func runMalwareScan(ctx context.Context, paths []string) error {
	cfg := GetConfig()
	if cfg == nil {
		return fmt.Errorf("configuration not loaded")
	}

	// Check for license
	if cfg.License == "" {
		logging.Error("No license key configured. Set WORDFENCE_CLI_LICENSE or use --license flag.")
		logging.Info("Visit https://www.wordfence.com/products/wordfence-cli/ to obtain a license.")
		return fmt.Errorf("license required")
	}

	// Read paths from stdin if requested
	if malwareScanReadStdin {
		stdinPaths, err := readPathsFromStdin()
		if err != nil {
			return fmt.Errorf("failed to read paths from stdin: %w", err)
		}
		paths = append(paths, stdinPaths...)
	}

	if len(paths) == 0 {
		return fmt.Errorf("no paths to scan")
	}

	logging.Info("Starting malware scan...")

	// Set up workers
	workers := malwareScanWorkers
	if workers <= 0 {
		workers = runtime.NumCPU()
	}

	logging.Debug("Workers: %d", workers)
	logging.Debug("Paths: %v", paths)

	// Create license
	license := api.NewLicense(cfg.License)

	// Create NOC1 client
	noc1 := api.NewNOC1Client(api.WithNOC1License(license))

	// Validate license
	logging.Verbose("Validating license...")
	valid, err := noc1.PingAPIKey(ctx)
	if err != nil {
		return fmt.Errorf("license validation failed: %w", err)
	}
	if !valid {
		return fmt.Errorf("invalid license key")
	}
	logging.Verbose("License valid (paid: %v)", license.Paid)

	// Set up cache
	var fileCache cache.Cache
	if cfg.CacheEnabled {
		cacheDir := cfg.CacheDirectory
		if cacheDir == "" {
			cacheDir, err = cache.DefaultCacheDir()
			if err != nil {
				logging.Warning("Failed to get default cache directory: %v", err)
				fileCache = &cache.NoOpCache{}
			}
		}
		if fileCache == nil {
			fileCache, err = cache.NewFileCache(cacheDir)
			if err != nil {
				logging.Warning("Failed to create file cache: %v", err)
				fileCache = &cache.NoOpCache{}
			}
		}
	} else {
		fileCache = &cache.NoOpCache{}
	}

	// Load signatures (from cache or API)
	sigSet, err := loadSignatures(ctx, noc1, fileCache)
	if err != nil {
		return fmt.Errorf("failed to load signatures: %w", err)
	}
	logging.Info("Loaded %d signatures", sigSet.Count())

	// Create file filter
	filterCfg := &scanner.FilterConfig{
		IncludeAll:      malwareScanIncludeAll,
		IncludeFiles:    malwareScanIncludeFiles,
		IncludePatterns: malwareScanIncludePattern,
		ExcludeFiles:    malwareScanExcludeFiles,
		ExcludePatterns: malwareScanExcludePattern,
	}
	filter, err := scanner.NewFilterFromConfig(filterCfg)
	if err != nil {
		return fmt.Errorf("failed to create file filter: %w", err)
	}

	// Create scanner
	s := scanner.NewScanner(sigSet,
		scanner.WithScanWorkers(workers),
		scanner.WithScanFilter(filter),
	)

	// Open output file
	var output *os.File
	if malwareScanOutput != "" {
		output, err = os.Create(malwareScanOutput)
		if err != nil {
			return fmt.Errorf("failed to create output file: %w", err)
		}
		defer output.Close()
	} else {
		output = os.Stdout
	}

	// Create output writer
	writer := newResultWriter(output, malwareScanOutputFormat, sigSet)
	defer writer.Close()

	// Start scanning
	results, err := s.Scan(ctx, paths...)
	if err != nil {
		return fmt.Errorf("scan failed: %w", err)
	}

	// Process results
	matchCount := 0
	for result := range results {
		if result.Error != nil {
			logging.Warning("Error scanning %s: %v", result.Path, result.Error)
			continue
		}

		if result.HasMatches() {
			matchCount += len(result.Matches)
			if err := writer.WriteResult(result, sigSet); err != nil {
				logging.Warning("Error writing result: %v", err)
			}
		}
	}

	// Print summary
	stats := s.GetStats()
	logging.Info("")
	logging.Info("Scan complete:")
	logging.Info("  Files scanned: %d", stats.FilesScanned)
	logging.Info("  Files matched: %d", stats.FilesMatched)
	logging.Info("  Files skipped: %d", stats.FilesSkipped)
	logging.Info("  Files errored: %d", stats.FilesErrored)
	logging.Info("  Total matches: %d", matchCount)
	logging.Info("  Duration: %v", stats.TotalDuration.Round(time.Millisecond))

	return nil
}

func readPathsFromStdin() ([]string, error) {
	var paths []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		path := strings.TrimSpace(scanner.Text())
		if path != "" {
			paths = append(paths, path)
		}
	}
	return paths, scanner.Err()
}

func loadSignatures(ctx context.Context, noc1 *api.NOC1Client, c cache.Cache) (*intel.SignatureSet, error) {
	const cacheKey = "signatures"
	const cacheMaxAge = 24 * time.Hour

	// Try to load from cache
	data, err := c.Get(cacheKey, cacheMaxAge)
	if err == nil {
		var sigSet intel.SignatureSet
		if err := json.Unmarshal(data, &sigSet); err == nil {
			logging.Debug("Loaded signatures from cache")
			return &sigSet, nil
		}
		logging.Debug("Failed to unmarshal cached signatures: %v", err)
	}

	// Fetch from API
	logging.Verbose("Fetching signatures from Wordfence API...")
	resp, err := noc1.GetPatterns(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch patterns: %w", err)
	}

	// Parse signatures
	sigSet, err := intel.ParseSignatureSet(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to parse signatures: %w", err)
	}

	// Cache the signatures
	data, err = json.Marshal(sigSet)
	if err != nil {
		logging.Warning("Failed to marshal signatures for cache: %v", err)
	} else {
		if err := c.Put(cacheKey, data); err != nil {
			logging.Warning("Failed to cache signatures: %v", err)
		}
	}

	return sigSet, nil
}

// resultWriter writes scan results in various formats
type resultWriter interface {
	WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error
	Close() error
}

func newResultWriter(output *os.File, format string, sigSet *intel.SignatureSet) resultWriter {
	switch format {
	case "csv":
		return newCSVWriter(output, ',')
	case "tsv":
		return newCSVWriter(output, '\t')
	case "json":
		return newJSONWriter(output)
	default:
		return newHumanWriter(output)
	}
}

// csvWriter writes results in CSV format
type csvWriter struct {
	writer *csv.Writer
	first  bool
}

func newCSVWriter(output *os.File, delim rune) *csvWriter {
	w := csv.NewWriter(output)
	w.Comma = delim
	// Write header
	w.Write([]string{"filename", "signature_id", "signature_name", "signature_description", "matched_text"})
	return &csvWriter{writer: w, first: true}
}

func (w *csvWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := ""
		desc := ""
		if sig != nil {
			name = sig.Name
			desc = sig.Description
		}
		w.writer.Write([]string{
			result.Path,
			fmt.Sprintf("%d", match.SignatureID),
			name,
			desc,
			match.MatchedString,
		})
	}
	return nil
}

func (w *csvWriter) Close() error {
	w.writer.Flush()
	return w.writer.Error()
}

// jsonWriter writes results in JSON format
type jsonWriter struct {
	output  *os.File
	encoder *json.Encoder
	first   bool
}

func newJSONWriter(output *os.File) *jsonWriter {
	output.WriteString("[\n")
	return &jsonWriter{output: output, encoder: json.NewEncoder(output), first: true}
}

type jsonResult struct {
	Filename             string `json:"filename"`
	SignatureID          int    `json:"signature_id"`
	SignatureName        string `json:"signature_name"`
	SignatureDescription string `json:"signature_description"`
	MatchedText          string `json:"matched_text"`
}

func (w *jsonWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := ""
		desc := ""
		if sig != nil {
			name = sig.Name
			desc = sig.Description
		}

		if !w.first {
			w.output.WriteString(",\n")
		}
		w.first = false

		jr := jsonResult{
			Filename:             result.Path,
			SignatureID:          match.SignatureID,
			SignatureName:        name,
			SignatureDescription: desc,
			MatchedText:          match.MatchedString,
		}
		data, _ := json.MarshalIndent(jr, "  ", "  ")
		w.output.WriteString("  ")
		w.output.Write(data)
	}
	return nil
}

func (w *jsonWriter) Close() error {
	w.output.WriteString("\n]\n")
	return nil
}

// humanWriter writes results in human-readable format
type humanWriter struct {
	output *os.File
}

func newHumanWriter(output *os.File) *humanWriter {
	return &humanWriter{output: output}
}

func (w *humanWriter) WriteResult(result *scanner.ScanResult, sigSet *intel.SignatureSet) error {
	red := color.New(color.FgRed, color.Bold)
	yellow := color.New(color.FgYellow)

	for _, match := range result.Matches {
		sig, _ := sigSet.GetSignature(match.SignatureID)
		name := fmt.Sprintf("Signature %d", match.SignatureID)
		if sig != nil && sig.Name != "" {
			name = sig.Name
		}

		red.Fprintf(w.output, "FOUND: ")
		fmt.Fprintf(w.output, "%s\n", result.Path)
		yellow.Fprintf(w.output, "  %s", name)
		if sig != nil && sig.Description != "" {
			fmt.Fprintf(w.output, " - %s", sig.Description)
		}
		fmt.Fprintln(w.output)
	}
	return nil
}

func (w *humanWriter) Close() error {
	return nil
}
